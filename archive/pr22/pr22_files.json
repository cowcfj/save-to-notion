[{"sha":"c7ce956f7c9b30e3f78df7869dfa84b3db4afa7a","filename":".github/workflows/test.yml","status":"modified","additions":13,"deletions":9,"changes":22,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/.github%2Fworkflows%2Ftest.yml","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/.github%2Fworkflows%2Ftest.yml","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/.github%2Fworkflows%2Ftest.yml?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -15,7 +15,7 @@ jobs:\n     \n     strategy:\n       matrix:\n-        node-version: [18.x, 20.x]\n+        node-version: [20.x]\n     \n     steps:\n     - name: Checkout repository\n@@ -47,12 +47,16 @@ jobs:\n         name: codecov-umbrella\n         fail_ci_if_error: false\n     \n-    - name: Report test results\n-      if: always()\n+    - name: Report success\n+      if: success()\n+      run: echo \"✅ All tests passed for Node.js ${{ matrix.node-version }}\"\n+\n+    - name: Report cancelled\n+      if: cancelled()\n+      run: echo \"⏹️ Tests cancelled for Node.js ${{ matrix.node-version }}\"\n+\n+    - name: Report failure\n+      if: ${{ failure() && !cancelled() }}\n       run: |\n-        if [ ${{ job.status }} == 'success' ]; then\n-          echo \"✅ All tests passed for Node.js ${{ matrix.node-version }}\"\n-        else\n-          echo \"❌ Tests failed for Node.js ${{ matrix.node-version }}\"\n-          exit 1\n-        fi\n+        echo \"❌ Tests failed for Node.js ${{ matrix.node-version }}\"\n+        exit 1"},{"sha":"f4af7f7e593c205999ee492f920f8a0ccf1293b6","filename":".qwen/settings.json","status":"added","additions":3,"deletions":0,"changes":3,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/.qwen%2Fsettings.json","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/.qwen%2Fsettings.json","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/.qwen%2Fsettings.json?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -0,0 +1,3 @@\n+{\n+  \"approvalMode\": \"auto-edit\"\n+}\n\\ No newline at end of file"},{"sha":"828c2413fc950904d847a90ac587bdc7ddb408e2","filename":"PR_DESCRIPTION.md","status":"removed","additions":0,"deletions":89,"changes":89,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/d0ac42a48cf3fd8b268dffd5a0ae68bd35809973/PR_DESCRIPTION.md","raw_url":"https://github.com/cowcfj/save-to-notion/raw/d0ac42a48cf3fd8b268dffd5a0ae68bd35809973/PR_DESCRIPTION.md","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/PR_DESCRIPTION.md?ref=d0ac42a48cf3fd8b268dffd5a0ae68bd35809973","patch":"@@ -1,89 +0,0 @@\n-# 🐛 Fix: Content Extraction Dependency Error\n-\n-## 📋 **Problem Description**\n-\n-Users were experiencing content extraction failures with the error message:\n-- **Original**: \"Failed to save: Could not parse the article content.\"\n-- **After initial fix**: \"Failed to save: Content extraction script returned no result.\"\n-\n-## 🔍 **Root Cause**\n-\n-The issue was caused by **PerformanceOptimizer dependency failures**:\n-- PerformanceOptimizer class failed to load or initialize properly\n-- When PerformanceOptimizer failed, the entire content extraction script would crash\n-- Script returned `null`/`undefined` instead of a valid result structure\n-- No fallback mechanism when optional dependencies were unavailable\n-\n-## ✅ **Solution**\n-\n-### 1. **Made PerformanceOptimizer Optional**\n-- Wrapped PerformanceOptimizer initialization in try-catch blocks\n-- Added graceful fallback when PerformanceOptimizer is unavailable\n-- Content extraction now works with or without optimization\n-\n-### 2. **Created Fallback Query System**\n-- Implemented `cachedQuery()` function with native DOM query fallback\n-- Replaced all `performanceOptimizer.cachedQuery()` calls with fallback function\n-- Ensures content extraction works regardless of dependency status\n-\n-### 3. **Enhanced Error Handling**\n-- Comprehensive try-catch blocks prevent dependency failures from crashing\n-- Detailed logging shows which query system is active\n-- Script always returns valid result structure\n-\n-## 📁 **Files Changed**\n-\n-- **`scripts/background.js`** - Made PerformanceOptimizer optional with fallback queries\n-- **`scripts/content.js`** - Added dependency safety checks and error handling  \n-- **`scripts/utils/imageUtils.js`** - Extracted image utilities for better modularity\n-- **`manifest.json`** - Updated content script includes\n-- **`BUGFIX_CONTENT_PARSING_ERROR.md`** - Complete documentation\n-\n-## 🧪 **Testing**\n-\n-### **Before Fix**\n-```\n-❌ Error: \"Content extraction script returned no result\"\n-❌ Extension fails when PerformanceOptimizer doesn't load\n-❌ No fallback mechanism\n-```\n-\n-### **After Fix**  \n-```\n-✅ Content extraction works with PerformanceOptimizer (optimized)\n-✅ Content extraction works without PerformanceOptimizer (fallback)\n-✅ Clear logging shows which system is active\n-✅ No more \"script returned no result\" errors\n-```\n-\n-### **Console Output Examples**\n-- **Success**: `✓ PerformanceOptimizer initialized successfully`\n-- **Fallback**: `⚠️ PerformanceOptimizer not available, using fallback queries`\n-\n-## 🚀 **Performance Impact**\n-\n-- **With PerformanceOptimizer**: Full optimization (caching + batching)\n-- **Without PerformanceOptimizer**: Slightly slower but fully functional native queries\n-- **Overhead**: Negligible dependency check cost\n-\n-## 🔄 **Backward Compatibility**\n-\n-✅ **Fully backward compatible**\n-- Works normally when PerformanceOptimizer loads (optimized performance)\n-- Falls back gracefully when PerformanceOptimizer fails (still functional)\n-- No breaking changes to existing functionality\n-\n-## 📊 **Benefits**\n-\n-- 🛡️ **Improved Reliability**: Content extraction works regardless of dependency status\n-- 🔄 **Graceful Degradation**: Automatic fallback to native queries\n-- 📝 **Better Debugging**: Clear logging shows active query system  \n-- 🎯 **Zero Failures**: Script always returns valid results\n-- 🚀 **Maintained Performance**: Still optimized when dependencies work\n-\n----\n-\n-**Fixes**: #[issue-number] (if applicable)\n-**Type**: Bug Fix\n-**Priority**: High (affects core functionality)\n-**Testing**: Manual testing completed, no regressions detected\n\\ No newline at end of file"},{"sha":"e66a10ef820e4864b6b7b349216953c67a701b47","filename":"QWEN.md","status":"added","additions":118,"deletions":0,"changes":118,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/QWEN.md","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/QWEN.md","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/QWEN.md?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -0,0 +1,118 @@\n+# QWEN.md - Notion Smart Clipper 項目上下文\n+\n+## 項目概述\n+\n+Notion Smart Clipper 是一個 Chrome 擴展，用於將網頁內容保存到 Notion，支持多色標註和智能內容提取。該擴展使用最新的 Chrome 擴展標準 (Manifest V3)，並具有豐富的功能集，包括智能內容提取、圖片處理、多色標註系統、模板自定義等。\n+\n+### 核心技術和架構\n+\n+- **Chrome Extension Manifest V3**: 使用最新的 Chrome 擴展標準\n+- **JavaScript**: 主要開發語言\n+- **CSS Highlight API**: 使用瀏覽器原生 API 實現標註功能，零 DOM 修改\n+- **Mozilla Readability**: 用於智能提取網頁主要內容\n+- **Jest**: 用於單元測試和集成測試\n+\n+### 項目結構\n+\n+```\n+notion-chrome/\n+├── manifest.json          # 擴展配置文件\n+├── package.json           # npm 配置文件\n+├── README.md              # 項目說明文件\n+├── USER_GUIDE.md          # 用戶指南\n+├── CHANGELOG.md           # 變更日誌\n+├── Agents.md              # AI Agent 工作指南\n+├── .github/               # GitHub 配置\n+│   └── workflows/          # GitHub Actions 工作流程\n+├── popup/                 # 彈出窗口 UI\n+├── options/               # 設置頁面（含搜索式數據庫選擇器）\n+├── scripts/               # 核心腳本\n+│   ├── background.js      # 後台腳本（Notion API、批處理）\n+│   ├── content.js         # 內容腳本（提取、圖片處理）\n+│   ├── highlighter-v2.js  # 新一代標註引擎（CSS Highlight API）\n+│   ├── performance/       # 性能優化模組\n+│   │   ├── PerformanceOptimizer.js     # 性能優化器\n+│   │   └── AdaptivePerformanceManager.js # 自適應性能管理器\n+│   └── utils.js           # 工具函數\n+├── lib/                   # 第三方庫\n+│   └── Readability.js     # Mozilla Readability\n+├── tests/                 # 測試文件（Jest）\n+│   ├── unit/              # 單元測試\n+│   │   ├── performance/    # 性能測試\n+│   │   │   ├── PerformanceOptimizer.test.js        # 基本性能測試\n+│   │   │   └── PerformanceOptimizerAdvanced.test.js # 進階性能測試\n+│   │   └── ...            # 其他單元測試\n+│   └── helpers/           # 測試輔助文件\n+│       └── performance.testable.js  # 可測試的性能優化器\n+└── icons/                 # 圖標文件\n+```\n+\n+## 構建和運行\n+\n+### 安裝依賴\n+\n+```bash\n+npm install\n+```\n+\n+### 運行測試\n+\n+```bash\n+# 運行所有測試\n+npm test\n+\n+# 運行測試並生成覆蓋率報告\n+npm run test:coverage\n+\n+# 運行測試並監聽文件變化\n+npm run test:watch\n+\n+# 運行 CI 測試（無交互模式）\n+npm run test:ci\n+```\n+\n+### 開發模式安裝擴展\n+\n+1. 打開 Chrome 瀏覽器，訪問 `chrome://extensions/`\n+2. 開啟「開發者模式」\n+3. 點擊「載入未封裝項目」\n+4. 選擇項目根目錄\n+\n+## 開發約定\n+\n+### 編碼風格\n+\n+- **JavaScript**: 遵循 ES6+ 語法標準\n+- **模組化**: 使用 CommonJS 模組系統\n+- **錯誤處理**: 完善的錯誤處理和日誌記錄\n+- **性能**: 關注性能優化，特別是在 DOM 操作和網絡請求方面\n+\n+### 測試實踐\n+\n+- **測試框架**: Jest\n+- **測試類型**: 單元測試、集成測試\n+- **測試覆蓋率**: 目標是保持高測試覆蓋率\n+- **測試文件**: 測試文件放在 `tests/` 目錄下，與被測文件一一對應\n+\n+### 性能優化系統\n+\n+Notion Smart Clipper v2.9.0 引入了全新的性能優化系統，包括：\n+\n+1. **DOM 查詢緩存**: 實施 LRU 緩存策略，重複查詢性能提升 20-50%\n+2. **批處理系統**: 圖片和 DOM 操作智能批量化，提升響應性和用戶體驗\n+3. **智能預加載**: 關鍵選擇器預加載機制，減少首次查詢延遲\n+4. **URL 驗證緩存**: 避免重複驗證相同圖片 URL，提升圖片處理速度\n+5. **性能監控**: 實時收集和顯示性能統計，包括緩存命中率、查詢時間等\n+\n+新增的性能優化功能包括：\n+- **緩存預熱機制**: `preloadSelectors` 和 `smartPrewarm` 方法\n+- **TTL (Time-To-Live) 機制**: 緩存過期時間管理\n+- **自適應性能策略**: `AdaptivePerformanceManager` 動態調整性能參數\n+- **改進的批處理調度算法**: 動態計算最佳批處理大小並非阻塞處理\n+\n+### 貢獻指南\n+\n+- **分支命名**: 使用 `feature/`, `fix/`, `chore/`, `docs/`, `refactor/` 等前綴\n+- **提交訊息**: 遵循 Conventional Commits 規範\n+- **Pull Request**: 使用提供的 PR 模板\n+- **代碼審核**: 所有代碼變更都需要通過代碼審核\n\\ No newline at end of file"},{"sha":"e2539404245b0b78882aa0fe579a7114d870c85f","filename":"github-mcp-temp.js","status":"added","additions":115,"deletions":0,"changes":115,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/github-mcp-temp.js","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/github-mcp-temp.js","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/github-mcp-temp.js?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -0,0 +1,115 @@\n+#!/usr/bin/env node\n+import { McpServer } from \"@modelcontextprotocol/sdk/server/mcp.js\";\n+import { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\n+import { Octokit } from \"@octokit/rest\";\n+import { z } from \"zod\";\n+\n+const GITHUB_TOKEN = process.env.GITHUB_PERSONAL_ACCESS_TOKEN;\n+if (!GITHUB_TOKEN) {\n+  throw new Error('GITHUB_PERSONAL_ACCESS_TOKEN environment variable is required');\n+}\n+\n+const octokit = new Octokit({\n+  auth: GITHUB_TOKEN,\n+});\n+\n+// Create an MCP server\n+const server = new McpServer({\n+  name: \"github-server\",\n+  version: \"0.1.0\"\n+});\n+\n+// Add a tool for getting PR reviews\n+server.tool(\n+  \"get_pr_reviews\",\n+  {\n+    owner: z.string().describe(\"Repository owner\"),\n+    repo: z.string().describe(\"Repository name\"),\n+    pull_number: z.number().describe(\"Pull request number\"),\n+  },\n+  async ({ owner, repo, pull_number }) => {\n+    try {\n+      // Get PR reviews\n+      const { data: reviews } = await octokit.pulls.listReviews({\n+        owner,\n+        repo,\n+        pull_number,\n+      });\n+\n+      // Get PR comments\n+      const { data: comments } = await octokit.pulls.listReviewComments({\n+        owner,\n+        repo,\n+        pull_number,\n+      });\n+\n+      // Get PR details\n+      const { data: pr } = await octokit.pulls.get({\n+        owner,\n+        repo,\n+        pull_number,\n+      });\n+\n+      const result = {\n+        pr: {\n+          number: pr.number,\n+          title: pr.title,\n+          state: pr.state,\n+          merged: pr.merged,\n+          mergeable: pr.mergeable,\n+          mergeable_state: pr.mergeable_state,\n+          head: {\n+            sha: pr.head.sha,\n+            ref: pr.head.ref,\n+          },\n+          base: {\n+            ref: pr.base.ref,\n+          },\n+          created_at: pr.created_at,\n+          updated_at: pr.updated_at,\n+        },\n+        reviews: reviews.map(review => ({\n+          id: review.id,\n+          user: review.user?.login,\n+          body: review.body,\n+          state: review.state,\n+          commit_id: review.commit_id,\n+          submitted_at: review.submitted_at,\n+        })),\n+        comments: comments.map(comment => ({\n+          id: comment.id,\n+          user: comment.user?.login,\n+          body: comment.body,\n+          path: comment.path,\n+          position: comment.position,\n+          commit_id: comment.commit_id,\n+          created_at: comment.created_at,\n+        })),\n+      };\n+\n+      return {\n+        content: [\n+          {\n+            type: \"text\",\n+            text: JSON.stringify(result, null, 2),\n+          },\n+        ],\n+      };\n+    } catch (error) {\n+      return {\n+        content: [\n+          {\n+            type: \"text\",\n+            text: `GitHub API error: ${error.message}`,\n+          },\n+        ],\n+        isError: true,\n+      };\n+    }\n+  }\n+);\n+\n+// Start receiving messages on stdin and sending messages on stdout\n+const transport = new StdioServerTransport();\n+await server.connect(transport);\n+console.error('GitHub MCP server running on stdio');\n\\ No newline at end of file"},{"sha":"b8f7f85e084535ba4304b32369075920d6c8325a","filename":"scripts/background.js","status":"modified","additions":9,"deletions":9,"changes":18,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fbackground.js","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fbackground.js","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/scripts%2Fbackground.js?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -1449,17 +1449,17 @@ async function handleSavePage(sendResponse) {\n                     performanceOptimizer = new PerformanceOptimizer({\n                         enableCache: true,\n                         enableBatching: true,\n-                        enableMetrics: true\n+                        enableMetrics: true,\n+                        cacheMaxSize: 500,  // 增加緩存大小以支持更多頁面元素\n+                        cacheTTL: 600000    // 10分鐘 TTL\n                     });\n                     \n-                    // 預加載關鍵選擇器\n-                    const criticalSelectors = [\n-                        'img[src]', 'img[data-src]', 'img[data-lazy-src]',\n-                        'article', 'main', '.content', '.post-content', '.entry-content',\n-                        'link[rel*=\"icon\"]', 'meta[property=\"og:image\"]'\n-                    ];\n-                    performanceOptimizer.preloadSelectors(criticalSelectors);\n-                    console.log('✓ PerformanceOptimizer initialized successfully');\n+                    // 使用智能預熱功能\n+                    performanceOptimizer.smartPrewarm(document).then(prewarmResult => {\n+                        console.log('✓ PerformanceOptimizer initialized successfully with smart prewarming');\n+                    }).catch(error => {\n+                        console.warn('⚠️ Smart prewarming failed:', error);\n+                    });\n                 } else {\n                     console.warn('⚠️ PerformanceOptimizer not available, using fallback queries');\n                 }"},{"sha":"b228288a187fb6fe8941ed7970709375c5a7e4e9","filename":"scripts/content.js","status":"modified","additions":8,"deletions":9,"changes":17,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fcontent.js","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fcontent.js","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/scripts%2Fcontent.js?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -1,5 +1,7 @@\n // This script is injected into the active tab.\n \n+/* global PerformanceOptimizer, ImageUtils, batchProcess, ErrorHandler */\n+\n (async function () {\n     try {\n         // 初始化性能優化器（如果可用）\n@@ -9,17 +11,14 @@\n                 performanceOptimizer = new PerformanceOptimizer({\n                     enableCache: true,\n                     enableBatching: true,\n-                    enableMetrics: true\n+                    enableMetrics: true,\n+                    cacheMaxSize: 500,  // 增加緩存大小以支持更多頁面元素\n+                    cacheTTL: 600000    // 10分鐘 TTL\n                 });\n \n-                // 預加載關鍵選擇器\n-                const criticalSelectors = [\n-                    'img[src]', 'img[data-src]', 'img[data-lazy-src]',\n-                    'article', 'main', '.content', '.post-content', '.entry-content',\n-                    '.node__content', '.field--name-field-image', '.field--name-field-body'\n-                ];\n-                performanceOptimizer.preloadSelectors(criticalSelectors);\n-                console.log('✓ PerformanceOptimizer initialized in content script');\n+                // 使用智能預熱功能\n+                const prewarmResult = await performanceOptimizer.smartPrewarm(document);\n+                console.log('✓ PerformanceOptimizer initialized in content script with smart prewarming');\n             } else {\n                 console.warn('⚠️ PerformanceOptimizer not available in content script, using fallback queries');\n             }"},{"sha":"9966a1880d9a7660c349c4308914bd09fdd088ae","filename":"scripts/highlighter-v2.js","status":"modified","additions":9,"deletions":2,"changes":11,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fhighlighter-v2.js","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fhighlighter-v2.js","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/scripts%2Fhighlighter-v2.js?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -2,7 +2,7 @@\n // v2.5.0 - 不修改DOM結構的標註實現\n (function() {\n     // 使用來自 utils.js 的共享函數\n-    const { normalizeUrl, StorageUtil, Logger } = window;\n+    const { normalizeUrl, StorageUtil } = window;\n \n     /**\n      * 檢查瀏覽器是否支持 CSS Custom Highlight API\n@@ -1285,6 +1285,7 @@\n         toolbar.querySelector('#close-highlight-v2').addEventListener('click', originalHide, { once: true });\n         \n         // 監控 toolbar 是否被移除，若被移除則自動重新掛載\n+        // 建立 MutationObserver 並在全域保留引用，避免被 GC\n         const mo = new MutationObserver(() => {\n             if (!document.body.contains(toolbar)) {\n                 try {\n@@ -1296,6 +1297,7 @@\n         });\n         try {\n             mo.observe(document.body, { childList: true, subtree: true });\n+            // 注意：稍後在 window.notionHighlighter 生成後，會把 mo 掛到 _observer 上\n             window.addEventListener('unload', () => mo.disconnect(), { once: true });\n         } catch (e) {\n             console.warn('MutationObserver 初始化失敗:', e);\n@@ -1605,6 +1607,7 @@\n         });\n \n         // 全局引用\n+        // 保留 observer 與監聽器綁定狀態於全域對象，避免被 GC 或重複綁定\n         window.notionHighlighter = {\n             manager: manager,\n             toolbar: toolbar,\n@@ -1641,7 +1644,11 @@\n                     console.error('隱藏標註工具欄失敗:', e);\n                 }\n             },\n-            collectHighlights: () => manager.collectHighlightsForNotion()\n+            collectHighlights: () => manager.collectHighlightsForNotion(),\n+            _observer: mo,\n+            _listenerBound: () => listenerBound,\n+            _bindDeleteListener: bindDeleteListener,\n+            _unbindDeleteListener: unbindDeleteListener\n         };\n \n         console.log('✅ 標註工具已初始化');"},{"sha":"4ee9626f8e91a2c0538fee8682065f3e6bfdd161","filename":"scripts/performance/AdaptivePerformanceManager.js","status":"added","additions":237,"deletions":0,"changes":237,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fperformance%2FAdaptivePerformanceManager.js","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fperformance%2FAdaptivePerformanceManager.js","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/scripts%2Fperformance%2FAdaptivePerformanceManager.js?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -0,0 +1,237 @@\n+/**\n+ * 自適應性能管理器\n+ * 根據頁面和系統性能動態調整優化策略\n+ */\n+const L = (typeof window !== 'undefined' && window.Logger) ? window.Logger : console;\n+class AdaptivePerformanceManager {\n+    /**\n+     * 創建自適應性能管理器實例\n+     * @param {PerformanceOptimizer} performanceOptimizer - 性能優化器實例\n+     * @param {Object} options - 配置選項\n+     */\n+    constructor(performanceOptimizer, options = {}) {\n+        this.performanceOptimizer = performanceOptimizer;\n+        this.options = {\n+            performanceThreshold: 100, // 性能基準線（ms）\n+            batchSizeAdjustmentFactor: 0.1, // 批處理大小調整因子\n+            cacheSizeAdjustmentFactor: 0.05, // 緩存大小調整因子\n+            ...options\n+        };\n+\n+        this.performanceHistory = []; // 性能歷史記錄\n+        this.currentSettings = {\n+            batchSize: 100,\n+            cacheSize: performanceOptimizer.options.cacheMaxSize,\n+            enableCache: true,\n+            enableBatching: true\n+        };\n+    }\n+\n+    /**\n+     * 分析當前頁面特性，調整性能策略\n+     * @param {Object} pageData - 頁面數據\n+     * @returns {Promise<Object>} 調整後的策略\n+     */\n+    async analyzeAndAdjust(pageData = {}) {\n+        const startTime = performance.now();\n+        \n+        // 分析頁面內容\n+        const pageAnalysis = this._analyzePageContent(pageData);\n+        \n+        // 分析系統性能\n+        const systemPerformance = await this._analyzeSystemPerformance();\n+        \n+        // 基於分析結果調整策略\n+        const strategy = this._adjustStrategyBasedOnAnalysis(pageAnalysis, systemPerformance);\n+        \n+        const duration = performance.now() - startTime;\n+        L.info(`📊 自適應性能分析完成，耗時: ${duration.toFixed(2)}ms`);\n+        \n+        return strategy;\n+    }\n+\n+    /**\n+     * 分析頁面內容以調整性能策略\n+     * @private\n+     */\n+    _analyzePageContent(pageData) {\n+        const analysis = {\n+            elementCount: 0,\n+            imageCount: 0,\n+            textLength: 0,\n+            complexityScore: 0\n+        };\n+\n+        try {\n+            // 分析當前文檔\n+            analysis.elementCount = document.querySelectorAll('*').length;\n+            analysis.imageCount = document.querySelectorAll('img').length;\n+            analysis.textLength = document?.body?.textContent?.length || 0;\n+            \n+            // 計算複雜度分數\n+            analysis.complexityScore = \n+                (analysis.elementCount / 1000) + \n+                (analysis.imageCount * 0.1) + \n+                (analysis.textLength / 10000);\n+        } catch (error) {\n+            L.warn('頁面內容分析失敗:', error);\n+        }\n+\n+        return analysis;\n+    }\n+\n+    /**\n+     * 分析系統性能\n+     * @private\n+     */\n+    async _analyzeSystemPerformance() {\n+        const performanceData = {\n+            memoryUsage: null,\n+            cpuLoad: null,\n+            networkCondition: 'good', // 'good', 'average', 'poor'\n+            performanceScore: 0\n+        };\n+\n+        try {\n+            // 獲取內存使用情況\n+            if (typeof performance !== 'undefined' && performance.memory) {\n+                performanceData.memoryUsage = {\n+                    used: performance.memory.usedJSHeapSize,\n+                    total: performance.memory.totalJSHeapSize,\n+                    limit: performance.memory.jsHeapSizeLimit,\n+                    usageRatio: performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize\n+                };\n+            }\n+\n+            // 執行簡單的性能測試\n+            const testStartTime = performance.now();\n+            const testArray = new Array(10000);\n+            for (let i = 0; i < 10000; i++) {\n+                testArray[i] = i * 2;\n+            }\n+            const testDuration = performance.now() - testStartTime;\n+            \n+            performanceData.performanceScore = testDuration;\n+            \n+            // 基於測試結果評估性能\n+            if (testDuration < 10) {\n+                performanceData.networkCondition = 'good';\n+            } else if (testDuration < 50) {\n+                performanceData.networkCondition = 'average';\n+            } else {\n+                performanceData.networkCondition = 'poor';\n+            }\n+            \n+        } catch (error) {\n+            L.warn('系統性能分析失敗:', error);\n+        }\n+\n+        return performanceData;\n+    }\n+\n+    /**\n+     * 根據分析結果調整策略\n+     * @private\n+     */\n+    _adjustStrategyBasedOnAnalysis(pageAnalysis, systemPerformance) {\n+        let newSettings = { ...this.currentSettings };\n+\n+        // 根據頁面複雜度調整緩存大小\n+        if (pageAnalysis.complexityScore > 10) {\n+            // 複雜頁面 -> 增加緩存大小\n+            newSettings.cacheSize = Math.min(\n+                Math.floor(this.performanceOptimizer.options.cacheMaxSize * 1.5),\n+                2000 // 最大緩存限制\n+            );\n+        } else if (pageAnalysis.complexityScore < 2) {\n+            // 簡單頁面 -> 減少緩存大小以節省內存\n+            newSettings.cacheSize = Math.floor(this.performanceOptimizer.options.cacheMaxSize * 0.7);\n+        }\n+\n+        // 根據系統性能調整批處理大小\n+        if (systemPerformance.performanceScore < 20) {\n+            // 高性能系統 -> 增加批處理大小\n+            newSettings.batchSize = Math.min(\n+                Math.floor(this.currentSettings.batchSize * 1.2),\n+                500 // 最大批處理大小\n+            );\n+        } else if (systemPerformance.performanceScore > 50) {\n+            // 低性能系統 -> 減少批處理大小\n+            newSettings.batchSize = Math.max(\n+                Math.floor(this.currentSettings.batchSize * 0.6),\n+                10 // 最小批處理大小\n+            );\n+        }\n+\n+        // 根據內存使用率決定是否啟用某些功能\n+        if (systemPerformance.memoryUsage && \n+            systemPerformance.memoryUsage.usageRatio > 0.8) {\n+            // 內存使用率高 -> 限制某些功能\n+            newSettings.enableCache = false; // 這可能不是最佳做法，僅作示例\n+        }\n+\n+        // 更新當前設置\n+        this.currentSettings = newSettings;\n+\n+        // 應用新設置到性能優化器\n+        this._applySettingsToOptimizer();\n+\n+        L.info('🔄 自適應性能策略調整完成:', newSettings);\n+        L.info('📊 頁面分析:', pageAnalysis);\n+        L.info('📊 系統性能:', systemPerformance);\n+\n+        return {\n+            settings: newSettings,\n+            pageAnalysis,\n+            systemPerformance\n+        };\n+    }\n+\n+    /**\n+     * 將調整後的設置應用到性能優化器\n+     * @private\n+     */\n+    _applySettingsToOptimizer() {\n+        if (this.performanceOptimizer) {\n+            // 更新緩存大小\n+            this.performanceOptimizer.options.cacheMaxSize = this.currentSettings.cacheSize;\n+            \n+            // 這裡可以添加更多設置的動態更新邏輯\n+            L.info(`🔧 已將新的性能設置應用到優化器:`, this.currentSettings);\n+        }\n+    }\n+\n+    /**\n+     * 動態調整批處理大小\n+     * @param {number} newBatchSize - 新的批處理大小\n+     */\n+    adjustBatchSize(newBatchSize) {\n+        this.currentSettings.batchSize = Math.max(1, Math.min(1000, newBatchSize));\n+        L.info(`🔄 批處理大小調整為: ${newBatchSize}`);\n+    }\n+\n+    /**\n+     * 動態調整緩存大小\n+     * @param {number} newCacheSize - 新的緩存大小\n+     */\n+    adjustCacheSize(newCacheSize) {\n+        this.currentSettings.cacheSize = Math.max(50, Math.min(2000, newCacheSize));\n+        this.performanceOptimizer.options.cacheMaxSize = this.currentSettings.cacheSize;\n+        L.info(`🔄 緩存大小調整為: ${newCacheSize}`);\n+    }\n+\n+    /**\n+     * 獲取當前性能策略\n+     * @returns {Object} 當前策略設置\n+     */\n+    getCurrentStrategy() {\n+        return { ...this.currentSettings };\n+    }\n+}\n+\n+// 導出類\n+if (typeof module !== 'undefined' && module.exports) {\n+    module.exports = { AdaptivePerformanceManager };\n+} else if (typeof window !== 'undefined') {\n+    window.AdaptivePerformanceManager = AdaptivePerformanceManager;\n+}\n\\ No newline at end of file"},{"sha":"959774379bbce0a7fe49a19d8161de97072dcfad","filename":"scripts/performance/PerformanceOptimizer.js","status":"modified","additions":426,"deletions":38,"changes":464,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fperformance%2FPerformanceOptimizer.js","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/scripts%2Fperformance%2FPerformanceOptimizer.js","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/scripts%2Fperformance%2FPerformanceOptimizer.js?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -2,6 +2,7 @@\n  * 性能優化器\n  * 提供 DOM 查詢緩存、批處理隊列和性能監控功能\n  */\n+const L = (typeof window !== 'undefined' && window.Logger) ? window.Logger : console;\n class PerformanceOptimizer {\n     /**\n      * 創建性能優化器實例\n@@ -15,6 +16,11 @@ class PerformanceOptimizer {\n             cacheMaxSize: 100,\n             batchDelay: 16, // 一個動畫幀的時間\n             metricsInterval: 5000, // 5秒收集一次指標\n+            cacheTTL: 300000, // 5分鐘 TTL\n+            prewarmSelectors: [ // 預設的預熱選擇器\n+                'img[src]', 'img[data-src]', 'article', 'main', '.content', '.post-content', '.entry-content'\n+            ],\n+            enableAdaptive: false, // 是否啟用自適應功能\n             ...options\n         };\n \n@@ -23,9 +29,14 @@ class PerformanceOptimizer {\n         this.cacheStats = {\n             hits: 0,\n             misses: 0,\n-            evictions: 0\n+            evictions: 0,\n+            prewarms: 0 // 預熱計數\n         };\n \n+        // 預熱相關屬性\n+        this.prewarmedSelectors = new Set();\n+        this.prewarmTimeout = null;\n+\n         // 批處理隊列\n         this.batchQueue = [];\n         this.batchTimer = null;\n@@ -44,12 +55,60 @@ class PerformanceOptimizer {\n             averageProcessingTime: 0\n         };\n \n+        // 自適應性能管理\n+        this.adaptiveManager = null;\n+        if (this.options.enableAdaptive) {\n+            this._initAdaptiveManager();\n+        }\n+\n         // 初始化性能監控\n         if (this.options.enableMetrics) {\n             this._initMetricsCollection();\n         }\n     }\n \n+    /**\n+     * 初始化自適應性能管理器\n+     * @private\n+     */\n+    _initAdaptiveManager() {\n+        try {\n+            if (typeof AdaptivePerformanceManager !== 'undefined') {\n+                this.adaptiveManager = new AdaptivePerformanceManager(this, {\n+                    performanceThreshold: 100,\n+                    batchSizeAdjustmentFactor: 0.1\n+                });\n+                L.info('🤖 自適應性能管理器已初始化');\n+            } else {\n+                L.warn('⚠️ AdaptivePerformanceManager not available, adaptive features disabled');\n+            }\n+        } catch (error) {\n+            L.error('❌ 初始化自適應管理器失敗:', error);\n+        }\n+    }\n+\n+    /**\n+     * 啟用自適應性能優化\n+     */\n+    enableAdaptiveOptimization() {\n+        if (!this.adaptiveManager) {\n+            this.options.enableAdaptive = true;\n+            this._initAdaptiveManager();\n+        }\n+    }\n+\n+    /**\n+     * 執行自適應性能調整\n+     * @param {Object} pageData - 頁面數據\n+     */\n+    async adaptiveAdjustment(pageData = {}) {\n+        if (!this.adaptiveManager) {\n+            return null;\n+        }\n+\n+        return await this.adaptiveManager.analyzeAndAdjust(pageData);\n+    }\n+\n     /**\n      * 緩存的 DOM 查詢\n      * @param {string} selector - CSS 選擇器\n@@ -74,12 +133,14 @@ class PerformanceOptimizer {\n             \n             const cached = this.queryCache.get(cacheKey);\n             \n-            // 驗證緩存的元素是否仍在 DOM 中\n-            if (this._validateCachedElements(cached.result)) {\n+            // 檢查緩存是否過期\n+            const isExpired = Date.now() - cached.timestamp > this.options.cacheTTL;\n+            \n+            if (!isExpired && this._validateCachedElements(cached.result)) {\n                 this._recordQueryTime(startTime);\n                 return cached.result;\n             } else {\n-                // 緩存失效，移除\n+                // 緩存過期或失效，移除\n                 this.queryCache.delete(cacheKey);\n             }\n         }\n@@ -92,19 +153,14 @@ class PerformanceOptimizer {\n         \n         // 緩存結果\n         if (result) {\n-            // 如果緩存已滿，移除最舊的項目\n-            if (this.queryCache.size >= this.options.cacheMaxSize) {\n-                const firstKey = this.queryCache.keys().next().value;\n-                if (firstKey) {\n-                    this.queryCache.delete(firstKey);\n-                    this.cacheStats.evictions++;\n-                }\n-            }\n+            // 維護緩存大小限制\n+            this._maintainCacheSizeLimit(cacheKey);\n             \n             this.queryCache.set(cacheKey, {\n                 result: result,\n                 timestamp: Date.now(),\n-                selector: selector\n+                selector: selector,\n+                ttl: this.options.cacheTTL\n             });\n         }\n \n@@ -229,7 +285,8 @@ class PerformanceOptimizer {\n             cache: {\n                 ...this.cacheStats,\n                 size: this.queryCache.size,\n-                hitRate: this.cacheStats.hits / (this.cacheStats.hits + this.cacheStats.misses) || 0\n+                hitRate: this.cacheStats.hits / (this.cacheStats.hits + this.cacheStats.misses) || 0,\n+                prewarmCount: this.prewarmedSelectors.size\n             },\n             batch: {\n                 ...this.batchStats\n@@ -323,17 +380,212 @@ class PerformanceOptimizer {\n         return false;\n     }\n \n+    /**\n+     * 預熱選擇器緩存\n+     * @param {Array} selectors - 要預熱的 CSS 選擇器數組\n+     * @param {Element} context - 查詢上下文，默認為 document\n+     * @returns {Promise<Array>} 預熱結果\n+     */\n+    async preloadSelectors(selectors, context = document) {\n+        if (!this.options.enableCache || !selectors || !Array.isArray(selectors)) {\n+            return [];\n+        }\n+\n+        L.info(`🔥 開始預熱 ${selectors.length} 個選擇器...`);\n+        \n+        // 使用批處理方式預熱選擇器\n+        const results = [];\n+        \n+        for (const selector of selectors) {\n+            if (this.prewarmedSelectors.has(selector)) {\n+                continue; // 已預熱過，跳過\n+            }\n+            \n+            try {\n+                // 執行查詢並將結果存入緩存\n+                const result = this.cachedQuery(selector, context);\n+                \n+                if (result) {\n+                    results.push({\n+                        selector: selector,\n+                        count: result.length || (result.nodeType ? 1 : 0),\n+                        cached: true\n+                    });\n+                    \n+                    this.cacheStats.prewarms++;\n+                    this.prewarmedSelectors.add(selector);\n+                    \n+                    L.info(`✓ 預熱成功: ${selector} (${results[results.length - 1].count} 個元素)`);\n+                }\n+            } catch (error) {\n+                L.warn(`⚠️ 預熱選擇器失敗: ${selector}`, error);\n+                \n+                if (typeof ErrorHandler !== 'undefined') {\n+                    ErrorHandler.logError({\n+                        type: 'preload_error',\n+                        context: `preloading selector: ${selector}`,\n+                        originalError: error,\n+                        timestamp: Date.now()\n+                    });\n+                }\n+                \n+                results.push({\n+                    selector: selector,\n+                    error: error.message,\n+                    cached: false\n+                });\n+            }\n+        }\n+        \n+        L.info(`🔥 預熱完成: ${results.filter(r => r.cached).length}/${selectors.length} 個選擇器已預熱`);\n+        return results;\n+    }\n+\n+    /**\n+     * 智能預熱 - 基於當前頁面內容自動預熱相關選擇器\n+     * @param {Element} context - 查詢上下文，默認為 document\n+     * @returns {Promise<Array>} 預熱結果\n+     */\n+    async smartPrewarm(context = document) {\n+        const startTime = performance.now();\n+        \n+        // 基於當前頁面分析，動態生成預熱選擇器\n+        const dynamicSelectors = this._analyzePageForPrewarming(context);\n+        \n+        // 合併配置中的預設選擇器和動態生成的選擇器\n+        const allSelectors = [...new Set([...this.options.prewarmSelectors, ...dynamicSelectors])];\n+        \n+        const results = await this.preloadSelectors(allSelectors, context);\n+        \n+        const duration = performance.now() - startTime;\n+        L.info(`🧠 智能預熱完成，耗時: ${duration.toFixed(2)}ms`);\n+        \n+        return results;\n+    }\n+\n+    /**\n+     * 基於當前頁面內容分析，動態生成預熱選擇器\n+     * @private\n+     */\n+    _analyzePageForPrewarming(context) {\n+        const selectors = [];\n+        \n+        // 檢查頁面結構，生成可能的選擇器\n+        if (context.querySelector('article')) {\n+            selectors.push('article h1', 'article h2', 'article h3', 'article p', 'article img');\n+        }\n+        \n+        if (context.querySelector('[role=\"main\"]')) {\n+            selectors.push('[role=\"main\"] *');\n+        }\n+        \n+        // 檢查是否有常見的 CMS 類名\n+        const cmsPatterns = ['.entry-content', '.post-content', '.article-content', '.content-area'];\n+        cmsPatterns.forEach(pattern => {\n+            if (context.querySelector(pattern)) {\n+                selectors.push(`${pattern} p`, `${pattern} img`, `${pattern} h1`, `${pattern} h2`, `${pattern} h3`);\n+            }\n+        });\n+        \n+        return selectors;\n+    }\n+\n+    /**\n+     * 維護緩存大小限制，實現 LRU 策略\n+     * @private\n+     */\n+    _maintainCacheSizeLimit(newKey) {\n+        if (this.queryCache.size < this.options.cacheMaxSize) {\n+            return; // 尚未達到最大大小，無需清理\n+        }\n+\n+        // 如果達到最大大小，移除最久未使用的項目\n+        const firstKey = this.queryCache.keys().next().value;\n+        if (firstKey && firstKey !== newKey) {\n+            this.queryCache.delete(firstKey);\n+            this.cacheStats.evictions++;\n+        }\n+    }\n+\n+    /**\n+     * 清理過期的緩存項目\n+     * @param {Object} options - 清理選項\n+     * @returns {number} 清理的項目數量\n+     */\n+    clearExpiredCache(options = {}) {\n+        const { force = false, maxAge = this.options.cacheTTL } = options;\n+        let clearedCount = 0;\n+\n+        // 如果強制清理，則清理所有緩存\n+        if (force) {\n+            clearedCount = this.queryCache.size;\n+            this.queryCache.clear();\n+            return clearedCount;\n+        }\n+\n+        // 否則只清理過期的緩存\n+        const now = Date.now();\n+        for (const [key, cached] of this.queryCache.entries()) {\n+            if (now - cached.timestamp > maxAge) {\n+                this.queryCache.delete(key);\n+                clearedCount++;\n+            }\n+        }\n+\n+        return clearedCount;\n+    }\n+\n+    /**\n+     * 強制刷新特定選擇器的緩存\n+     * @param {string|Array} selectors - 要刷新的選擇器或選擇器數組\n+     * @param {Element} context - 查詢上下文\n+     * @param {Object} options - 查詢選項\n+     */\n+    refreshCache(selectors, context = document, options = {}) {\n+        const selectorList = Array.isArray(selectors) ? selectors : [selectors];\n+        \n+        for (const selector of selectorList) {\n+            const cacheKey = this._generateCacheKey(selector, context, options);\n+            if (this.queryCache.has(cacheKey)) {\n+                // 執行新的查詢並更新緩存\n+                const result = this._performQuery(selector, context, options);\n+                \n+                if (result) {\n+                    this.queryCache.set(cacheKey, {\n+                        result: result,\n+                        timestamp: Date.now(),\n+                        selector: selector,\n+                        ttl: this.options.cacheTTL\n+                    });\n+                } else {\n+                    // 如果新查詢沒有結果，則刪除緩存\n+                    this.queryCache.delete(cacheKey);\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * 安排批處理\n      * @private\n      */\n     _scheduleBatchProcessing() {\n         if (this.batchTimer) return;\n \n-        this.batchTimer = setTimeout(() => {\n-            this._processBatch();\n-            this.batchTimer = null;\n-        }, this.options.batchDelay);\n+        // 使用 requestAnimationFrame 進行更優化的調度\n+        // 如果支持 requestIdleCallback，則優先使用它\n+        if (typeof requestIdleCallback !== 'undefined') {\n+            this.batchTimer = requestIdleCallback(() => {\n+                this._processBatch();\n+                this.batchTimer = null;\n+            }, { timeout: this.options.batchDelay });\n+        } else {\n+            // 回退到 setTimeout\n+            this.batchTimer = setTimeout(() => {\n+                this._processBatch();\n+                this.batchTimer = null;\n+            }, this.options.batchDelay);\n+        }\n     }\n \n     /**\n@@ -343,26 +595,70 @@ class PerformanceOptimizer {\n     _processBatch() {\n         if (this.batchQueue.length === 0) return;\n \n+        // 動態調整批處理大小，根據隊列大小決定是否分批處理\n+        const maxBatchSize = this._calculateOptimalBatchSize();\n+        const currentBatch = this.batchQueue.length > maxBatchSize \n+            ? this.batchQueue.splice(0, maxBatchSize) \n+            : [...this.batchQueue];\n+        \n+        this.batchQueue = this.batchQueue.length > maxBatchSize \n+            ? this.batchQueue \n+            : [];\n+\n         const startTime = performance.now();\n-        const currentBatch = [...this.batchQueue];\n-        this.batchQueue = [];\n \n         // 更新批處理統計\n         this.batchStats.totalBatches++;\n         this.batchStats.totalItems += currentBatch.length;\n         this.batchStats.averageBatchSize = this.batchStats.totalItems / this.batchStats.totalBatches;\n \n-        // 處理每個批處理項目\n-        currentBatch.forEach(item => {\n+        // 分批處理以避免阻塞 UI\n+        this._processBatchItems(currentBatch, startTime);\n+    }\n+\n+    /**\n+     * 計算最佳批處理大小\n+     * @private\n+     */\n+    _calculateOptimalBatchSize() {\n+        // 根據隊列大小和歷史性能數據動態調整\n+        const queueLength = this.batchQueue.length;\n+        \n+        if (queueLength === 0) return 100; // 默認大小\n+        \n+        // 如果隊列很長，使用較大的批處理以提高效率\n+        if (queueLength > 500) return 200;\n+        if (queueLength > 200) return 150;\n+        if (queueLength > 50) return 100;\n+        \n+        // 如果隊列較短，使用較小的批處理以保持響應性\n+        return 50;\n+    }\n+\n+    /**\n+     * 分批處理項目以避免阻塞 UI\n+     * @private\n+     */\n+    _processBatchItems(items, startTime, index = 0, results = []) {\n+        const chunkSize = 10; // 每次處理的項目數量\n+        const endIndex = Math.min(index + chunkSize, items.length);\n+\n+        // 處理當前塊\n+        for (let i = index; i < endIndex; i++) {\n+            const item = items[i];\n             try {\n                 if (item.type === 'dom') {\n                     // DOM 操作批處理\n-                    const results = item.operations.map(op => op());\n-                    item.resolve(results);\n+                    const result = item.operations.map(op => op());\n+                    item.resolve(result);\n+                    results.push(result);\n                 } else {\n-                    // 圖片處理批處理\n-                    const results = item.images.map(item.processor);\n-                    item.resolve(results);\n+                    // 圖片處理批處理或其他處理\n+                    const result = Array.isArray(item.images) \n+                        ? item.images.map(img => item.processor(img))\n+                        : [item.processor()]; // 處理單個項目\n+                    item.resolve(result);\n+                    results.push(result);\n                 }\n             } catch (error) {\n                 if (typeof ErrorHandler !== 'undefined') {\n@@ -375,13 +671,27 @@ class PerformanceOptimizer {\n                 }\n                 item.resolve([]);\n             }\n-        });\n+        }\n \n-        // 記錄處理時間\n-        const processingTime = performance.now() - startTime;\n-        this.metrics.totalProcessingTime += processingTime;\n-        this.metrics.batchOperations++;\n-        this.metrics.averageProcessingTime = this.metrics.totalProcessingTime / this.metrics.batchOperations;\n+        // 如果還有更多項目，安排下一塊處理\n+        if (endIndex < items.length) {\n+            // 使用 requestAnimationFrame 或 setTimeout 來讓出控制權\n+            if (typeof requestAnimationFrame !== 'undefined') {\n+                requestAnimationFrame(() => {\n+                    this._processBatchItems(items, startTime, endIndex, results);\n+                });\n+            } else {\n+                setTimeout(() => {\n+                    this._processBatchItems(items, startTime, endIndex, results);\n+                }, 0);\n+            }\n+        } else {\n+            // 所有項目已完成處理\n+            const processingTime = performance.now() - startTime;\n+            this.metrics.totalProcessingTime += processingTime;\n+            this.metrics.batchOperations++;\n+            this.metrics.averageProcessingTime = this.metrics.totalProcessingTime / this.metrics.batchOperations;\n+        }\n     }\n \n     /**\n@@ -393,16 +703,65 @@ class PerformanceOptimizer {\n         \n         for (let i = 0; i < items.length; i += batchSize) {\n             const batch = items.slice(i, i + batchSize);\n-            const batchPromises = batch.map(processor);\n-            const batchResults = await Promise.allSettled(batchPromises);\n             \n-            results.push(...batchResults.map(result => \n-                result.status === 'fulfilled' ? result.value : { error: result.reason }\n-            ));\n+            // 使用動態批處理大小調整\n+            const dynamicBatchSize = this._adjustBatchSizeForPerformance(batch.length);\n+            if (dynamicBatchSize < batch.length) {\n+                // 如果動態大小小於當前批次，進行細分\n+                for (let j = 0; j < batch.length; j += dynamicBatchSize) {\n+                    const subBatch = batch.slice(j, j + dynamicBatchSize);\n+                    const subBatchPromises = subBatch.map(processor);\n+                    const subBatchResults = await Promise.allSettled(subBatchPromises);\n+                    \n+                    results.push(...subBatchResults.map(result => \n+                        result.status === 'fulfilled' ? result.value : { error: result.reason }\n+                    ));\n+                    \n+                    // 在批次之間提供短暫延遲以保持 UI 響應\n+                    await this._yieldToMain();\n+                }\n+            } else {\n+                const batchPromises = batch.map(processor);\n+                const batchResults = await Promise.allSettled(batchPromises);\n+                \n+                results.push(...batchResults.map(result => \n+                    result.status === 'fulfilled' ? result.value : { error: result.reason }\n+                ));\n+            }\n         }\n         \n         return results;\n     }\n+    \n+    /**\n+     * 根據性能動態調整批處理大小\n+     * @private\n+     */\n+    _adjustBatchSizeForPerformance(currentSize) {\n+        // 如果有性能歷史數據，根據歷史性能調整大小\n+        if (this.metrics.averageProcessingTime && this.metrics.averageProcessingTime > 100) {\n+            // 如果平均處理時間過長，減少批次大小\n+            return Math.max(1, Math.floor(currentSize * 0.7));\n+        } else if (this.metrics.averageProcessingTime && this.metrics.averageProcessingTime < 10) {\n+            // 如果處理很快，可以增加批次大小\n+            return Math.min(500, currentSize * 1.5);\n+        }\n+        return currentSize;\n+    }\n+    \n+    /**\n+     * 讓出控制權給主線程以保持響應性\n+     * @private\n+     */\n+    _yieldToMain() {\n+        return new Promise(resolve => {\n+            if (typeof requestIdleCallback !== 'undefined') {\n+                requestIdleCallback(() => resolve());\n+            } else {\n+                setTimeout(() => resolve(), 1);  // 給瀏覽器機會處理其他任務\n+            }\n+        });\n+    }\n \n     /**\n      * 記錄查詢時間\n@@ -460,6 +819,35 @@ class PerformanceOptimizer {\n         }\n         return null;\n     }\n+\n+    /**\n+     * 根據當前系統負載調整性能參數\n+     */\n+    async adjustForSystemLoad() {\n+        // 獲取當前性能指標\n+        const stats = this.getStats();\n+        \n+        // 根據緩存命中率調整策略\n+        if (stats.cache.hitRate < 0.3) {\n+            // 緩存命中率低，可能需要增加緩存大小或清理策略\n+            L.info('📊 緩存命中率較低，考慮調整緩存策略');\n+        }\n+        \n+        // 根據平均處理時間調整批處理大小\n+        if (stats.metrics.averageProcessingTime > 50) {\n+            // 處理時間過長，減少批處理大小\n+            L.info('⏰ 處理時間過長，動態調整批處理大小');\n+            if (this.adaptiveManager) {\n+                this.adaptiveManager.adjustBatchSize(Math.floor(this.currentSettings.batchSize * 0.8));\n+            }\n+        }\n+        \n+        // 定期清理過期緩存\n+        const expiredCount = this.clearExpiredCache();\n+        if (expiredCount > 0) {\n+            L.info(`🧹 清理了 ${expiredCount} 個過期的緩存項目`);\n+        }\n+    }\n }\n \n // 創建默認實例"},{"sha":"ae23657e7f56aa3dc12e55db5af113c8459e246a","filename":"tests/helpers/performance.testable.js","status":"modified","additions":357,"deletions":14,"changes":371,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/tests%2Fhelpers%2Fperformance.testable.js","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/tests%2Fhelpers%2Fperformance.testable.js","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/tests%2Fhelpers%2Fperformance.testable.js?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -20,6 +20,11 @@ class PerformanceOptimizer {\n             cacheMaxSize: 1000,\n             batchDelay: 16, // 一個動畫幀的時間\n             metricsInterval: 5000, // 5秒收集一次指標\n+            cacheTTL: 300000, // 5分鐘 TTL\n+            prewarmSelectors: [ // 預設的預熱選擇器\n+                'img[src]', 'img[data-src]', 'article', 'main', '.content', '.post-content', '.entry-content'\n+            ],\n+            enableAdaptive: false, // 是否啟用自適應功能\n             ...options\n         };\n         \n@@ -28,21 +33,71 @@ class PerformanceOptimizer {\n         this.cacheStats = {\n             hits: 0,\n             misses: 0,\n-            evictions: 0\n+            evictions: 0,\n+            prewarms: 0 // 預熱計數\n         };\n+\n+        // 預熱相關屬性\n+        this.prewarmedSelectors = new Set();\n+        this.prewarmTimeout = null;\n         \n         // 批處理隊列\n         this.batchQueue = [];\n         this.batchTimer = null;\n         this.processingBatch = false;\n+        this.batchStats = {\n+            totalBatches: 0,\n+            totalItems: 0,\n+            averageBatchSize: 0\n+        };\n         \n         // 性能指標\n         this.metrics = {\n             domQueries: 0,\n             cacheHits: 0,\n             batchOperations: 0,\n             averageQueryTime: 0,\n-            totalQueryTime: 0\n+            totalQueryTime: 0,\n+            totalProcessingTime: 0,\n+            averageProcessingTime: 0\n+        };\n+\n+        // 自適應性能管理\n+        this.adaptiveManager = null;\n+        if (this.options.enableAdaptive) {\n+            this._initAdaptiveManager();\n+        }\n+    }\n+\n+    /**\n+     * 初始化自適應性能管理器\n+     * @private\n+     */\n+    _initAdaptiveManager() {\n+        // 在測試環境中不實現複雜的自適應邏輯\n+        console.log('🤖 自適應性能管理器已初始化（測試環境）');\n+    }\n+\n+    /**\n+     * 啟用自適應性能優化\n+     */\n+    enableAdaptiveOptimization() {\n+        if (!this.adaptiveManager) {\n+            this.options.enableAdaptive = true;\n+            this._initAdaptiveManager();\n+        }\n+    }\n+\n+    /**\n+     * 執行自適應性能調整\n+     * @param {Object} pageData - 頁面數據\n+     */\n+    async adaptiveAdjustment(pageData = {}) {\n+        // 在測試環境中返回基本結果\n+        return {\n+            settings: { ...this.currentSettings },\n+            pageAnalysis: { elementCount: 0, imageCount: 0, textLength: 0, complexityScore: 0 },\n+            systemPerformance: { memoryUsage: null, cpuLoad: null, networkCondition: 'good', performanceScore: 0 }\n         };\n     }\n \n@@ -62,9 +117,19 @@ class PerformanceOptimizer {\n         \n         // 檢查緩存\n         if (this.queryCache.has(cacheKey)) {\n-            this.cacheStats.hits++;\n-            this.metrics.cacheHits++;\n-            return this.queryCache.get(cacheKey).result;\n+            const cached = this.queryCache.get(cacheKey);\n+            \n+            // 檢查緩存是否過期\n+            const isExpired = Date.now() - cached.timestamp > this.options.cacheTTL;\n+            \n+            if (!isExpired) {\n+                this.cacheStats.hits++;\n+                this.metrics.cacheHits++;\n+                return cached.result;\n+            } else {\n+                // 緩存過期，移除\n+                this.queryCache.delete(cacheKey);\n+            }\n         }\n \n         // 執行查詢\n@@ -138,12 +203,171 @@ class PerformanceOptimizer {\n         });\n     }\n \n+    /**\n+     * 預熱選擇器緩存\n+     * @param {Array} selectors - 要預熱的 CSS 選擇器數組\n+     * @param {Element} context - 查詢上下文，默認為 document\n+     * @returns {Promise<Array>} 預熱結果\n+     */\n+    async preloadSelectors(selectors, context = document) {\n+        if (!this.options.enableCache || !selectors || !Array.isArray(selectors)) {\n+            return [];\n+        }\n+\n+        console.log(`🔥 開始預熱 ${selectors.length} 個選擇器...`);\n+        \n+        // 使用批處理方式預熱選擇器\n+        const results = [];\n+        \n+        for (const selector of selectors) {\n+            if (this.prewarmedSelectors.has(selector)) {\n+                continue; // 已預熱過，跳過\n+            }\n+            \n+            try {\n+                // 執行查詢並將結果存入緩存\n+                const result = this.cachedQuery(selector, context);\n+                \n+                if (result) {\n+                    results.push({\n+                        selector: selector,\n+                        count: Array.isArray(result) ? result.length : (result.nodeType ? 1 : 0),\n+                        cached: true\n+                    });\n+                    \n+                    this.cacheStats.prewarms++;\n+                    this.prewarmedSelectors.add(selector);\n+                    \n+                    console.log(`✓ 預熱成功: ${selector} (${results[results.length - 1].count} 個元素)`);\n+                }\n+            } catch (error) {\n+                console.warn(`⚠️ 預熱選擇器失敗: ${selector}`, error);\n+                \n+                results.push({\n+                    selector: selector,\n+                    error: error.message,\n+                    cached: false\n+                });\n+            }\n+        }\n+        \n+        console.log(`🔥 預熱完成: ${results.filter(r => r.cached).length}/${selectors.length} 個選擇器已預熱`);\n+        return results;\n+    }\n+\n+    /**\n+     * 智能預熱 - 基於當前頁面內容自動預熱相關選擇器\n+     * @param {Element} context - 查詢上下文，默認為 document\n+     * @returns {Promise<Array>} 預熱結果\n+     */\n+    async smartPrewarm(context = document) {\n+        const startTime = performance.now();\n+        \n+        // 基於當前頁面分析，動態生成預熱選擇器\n+        const dynamicSelectors = this._analyzePageForPrewarming(context);\n+        \n+        // 合併配置中的預設選擇器和動態生成的選擇器\n+        const allSelectors = [...new Set([...this.options.prewarmSelectors, ...dynamicSelectors])];\n+        \n+        const results = await this.preloadSelectors(allSelectors, context);\n+        \n+        const duration = performance.now() - startTime;\n+        console.log(`🧠 智能預熱完成，耗時: ${duration.toFixed(2)}ms`);\n+        \n+        return results;\n+    }\n+\n+    /**\n+     * 基於當前頁面內容分析，動態生成預熱選擇器\n+     * @private\n+     */\n+    _analyzePageForPrewarming(context) {\n+        const selectors = [];\n+        \n+        // 檢查頁面結構，生成可能的選擇器\n+        if (context.querySelector('article')) {\n+            selectors.push('article h1', 'article h2', 'article h3', 'article p', 'article img');\n+        }\n+        \n+        if (context.querySelector('[role=\"main\"]')) {\n+            selectors.push('[role=\"main\"] *');\n+        }\n+        \n+        // 檢查是否有常見的 CMS 類名\n+        const cmsPatterns = ['.entry-content', '.post-content', '.article-content', '.content-area'];\n+        cmsPatterns.forEach(pattern => {\n+            if (context.querySelector(pattern)) {\n+                selectors.push(`${pattern} p`, `${pattern} img`, `${pattern} h1`, `${pattern} h2`, `${pattern} h3`);\n+            }\n+        });\n+        \n+        return selectors;\n+    }\n+\n+    /**\n+     * 清理過期的緩存項目\n+     * @param {Object} options - 清理選項\n+     * @returns {number} 清理的項目數量\n+     */\n+    clearExpiredCache(options = {}) {\n+        const { force = false, maxAge = this.options.cacheTTL } = options;\n+        let clearedCount = 0;\n+\n+        // 如果強制清理，則清理所有緩存\n+        if (force) {\n+            clearedCount = this.queryCache.size;\n+            this.queryCache.clear();\n+            return clearedCount;\n+        }\n+\n+        // 否則只清理過期的緩存\n+        const now = Date.now();\n+        for (const [key, cached] of this.queryCache.entries()) {\n+            if (now - cached.timestamp > maxAge) {\n+                this.queryCache.delete(key);\n+                clearedCount++;\n+            }\n+        }\n+\n+        return clearedCount;\n+    }\n+\n+    /**\n+     * 強制刷新特定選擇器的緩存\n+     * @param {string|Array} selectors - 要刷新的選擇器或選擇器數組\n+     * @param {Element} context - 查詢上下文\n+     * @param {Object} options - 查詢選項\n+     */\n+    refreshCache(selectors, context = document, options = {}) {\n+        const selectorList = Array.isArray(selectors) ? selectors : [selectors];\n+        \n+        for (const selector of selectorList) {\n+            const cacheKey = this._generateCacheKey(selector, context, options);\n+            if (this.queryCache.has(cacheKey)) {\n+                // 執行新的查詢並更新緩存\n+                const result = this._performQuery(selector, context, options);\n+                \n+                if (result) {\n+                    this.queryCache.set(cacheKey, {\n+                        result: result,\n+                        timestamp: Date.now(),\n+                        selector: selector,\n+                        ttl: this.options.cacheTTL\n+                    });\n+                } else {\n+                    // 如果新查詢沒有結果，則刪除緩存\n+                    this.queryCache.delete(cacheKey);\n+                }\n+            }\n+        }\n+    }\n+\n     /**\n      * 預加載關鍵選擇器\n      * @param {Array} selectors - 選擇器數組\n      * @param {Element} context - 查詢上下文\n      */\n-    preloadSelectors(selectors, context = document) {\n+    preloadSelectorsOld(selectors, context = document) {\n         if (!this.options.enableCache) return;\n \n         // 使用 setTimeout 模擬 requestIdleCallback\n@@ -175,10 +399,28 @@ class PerformanceOptimizer {\n         this.cacheStats = {\n             hits: 0,\n             misses: 0,\n-            evictions: 0\n+            evictions: 0,\n+            prewarms: 0\n         };\n     }\n \n+    /**\n+     * 維護緩存大小限制，實現 LRU 策略\n+     * @private\n+     */\n+    _maintainCacheSizeLimit(newKey) {\n+        if (this.queryCache.size < this.options.cacheMaxSize) {\n+            return; // 尚未達到最大大小，無需清理\n+        }\n+\n+        // 如果達到最大大小，移除最久未使用的項目\n+        const firstKey = this.queryCache.keys().next().value;\n+        if (firstKey && firstKey !== newKey) {\n+            this.queryCache.delete(firstKey);\n+            this.cacheStats.evictions++;\n+        }\n+    }\n+\n     /**\n      * 獲取性能統計\n      * @returns {Object} 性能統計信息\n@@ -193,17 +435,22 @@ class PerformanceOptimizer {\n                 size: this.queryCache.size,\n                 maxSize: this.options.cacheMaxSize,\n                 hitRate: `${cacheHitRate}%`,\n+                prewarmCount: this.prewarmedSelectors.size,\n                 ...this.cacheStats\n             },\n             batch: {\n                 queueSize: this.batchQueue.length,\n                 processing: this.processingBatch,\n-                totalOperations: this.metrics.batchOperations\n+                totalOperations: this.metrics.batchOperations,\n+                ...this.batchStats\n             },\n             queries: {\n                 total: this.metrics.domQueries,\n                 averageTime: `${this.metrics.averageQueryTime.toFixed(2)}ms`,\n                 totalTime: `${this.metrics.totalQueryTime.toFixed(2)}ms`\n+            },\n+            metrics: {\n+                ...this.metrics\n             }\n         };\n     }\n@@ -258,21 +505,21 @@ class PerformanceOptimizer {\n                 result: result,\n                 timestamp: Date.now(),\n                 queryTime: queryTime,\n-                accessCount: 1\n+                accessCount: 1,\n+                ttl: this.options.cacheTTL\n             });\n             return;\n         }\n \n-        // 檢查緩存大小限制（新鍵）\n-        if (this.queryCache.size >= this.options.cacheMaxSize) {\n-            this._evictOldestCache();\n-        }\n+        // 維護緩存大小限制\n+        this._maintainCacheSizeLimit(key);\n \n         this.queryCache.set(key, {\n             result: result,\n             timestamp: Date.now(),\n             queryTime: queryTime,\n-            accessCount: 1\n+            accessCount: 1,\n+            ttl: this.options.cacheTTL\n         });\n     }\n \n@@ -322,6 +569,11 @@ class PerformanceOptimizer {\n         this.batchQueue.length = 0;\n \n         try {\n+            // 更新批處理統計\n+            this.batchStats.totalBatches++;\n+            this.batchStats.totalItems += currentBatch.length;\n+            this.batchStats.averageBatchSize = this.batchStats.totalItems / this.batchStats.totalBatches;\n+\n             // 按類型分組處理\n             const imagesBatch = currentBatch.filter(item => item.type === 'images');\n             const domBatch = currentBatch.filter(item => item.type === 'dom');\n@@ -354,6 +606,52 @@ class PerformanceOptimizer {\n         }\n     }\n \n+    /**\n+     * 分批處理數組\n+     * @private\n+     */\n+    async _processInBatches(items, batchSize, processor) {\n+        const results = [];\n+        \n+        for (let i = 0; i < items.length; i += batchSize) {\n+            const batch = items.slice(i, i + batchSize);\n+            const batchPromises = batch.map(processor);\n+            const batchResults = await Promise.allSettled(batchPromises);\n+            \n+            results.push(...batchResults.map(result => \n+                result.status === 'fulfilled' ? result.value : { error: result.reason }\n+            ));\n+        }\n+        \n+        return results;\n+    }\n+    \n+    /**\n+     * 根據性能動態調整批處理大小\n+     * @private\n+     */\n+    _adjustBatchSizeForPerformance(currentSize) {\n+        // 如果有性能歷史數據，根據歷史性能調整大小\n+        if (this.metrics.averageProcessingTime && this.metrics.averageProcessingTime > 100) {\n+            // 如果平均處理時間過長，減少批次大小\n+            return Math.max(1, Math.floor(currentSize * 0.7));\n+        } else if (this.metrics.averageProcessingTime && this.metrics.averageProcessingTime < 10) {\n+            // 如果處理很快，可以增加批次大小\n+            return Math.min(500, currentSize * 1.5);\n+        }\n+        return currentSize;\n+    }\n+    \n+    /**\n+     * 讓出控制權給主線程以保持響應性\n+     * @private\n+     */\n+    _yieldToMain() {\n+        return new Promise(resolve => {\n+            setTimeout(() => resolve(), 1);  // 給瀏覽器機會處理其他任務\n+        });\n+    }\n+\n     /**\n      * 測量函數執行時間\n      * @param {Function} fn - 要測量的函數\n@@ -381,6 +679,51 @@ class PerformanceOptimizer {\n         console.info(`Performance: ${name} took ${(endTime - startTime).toFixed(2)}ms`);\n         return result;\n     }\n+\n+    /**\n+     * 計算最佳批處理大小\n+     * @private\n+     */\n+    _calculateOptimalBatchSize() {\n+        // 根據隊列大小和歷史性能數據動態調整\n+        const queueLength = this.batchQueue.length;\n+        \n+        if (queueLength === 0) return 100; // 默認大小\n+        \n+        // 如果隊列很長，使用較大的批處理以提高效率\n+        if (queueLength > 500) return 200;\n+        if (queueLength > 200) return 150;\n+        if (queueLength > 50) return 100;\n+        \n+        // 如果隊列較短，使用較小的批處理以保持響應性\n+        return 50;\n+    }\n+\n+    /**\n+     * 根據當前系統負載調整性能參數\n+     */\n+    async adjustForSystemLoad() {\n+        // 獲取當前性能指標\n+        const stats = this.getPerformanceStats();\n+        \n+        // 根據緩存命中率調整策略\n+        if (stats.cache.hitRate < 0.3) {\n+            // 緩存命中率低，可能需要增加緩存大小或清理策略\n+            console.log('📊 緩存命中率較低，考慮調整緩存策略');\n+        }\n+        \n+        // 根據平均處理時間調整批處理大小\n+        if (this.metrics.averageProcessingTime > 50) {\n+            // 處理時間過長，減少批處理大小\n+            console.log('⏰ 處理時間過長，動態調整批處理大小');\n+        }\n+        \n+        // 定期清理過期緩存\n+        const expiredCount = this.clearExpiredCache();\n+        if (expiredCount > 0) {\n+            console.log(`🧹 清理了 ${expiredCount} 個過期的緩存項目`);\n+        }\n+    }\n }\n \n module.exports = { PerformanceOptimizer };\n\\ No newline at end of file"},{"sha":"95f96f25aa7c85f5d51949cf02738cc65b211c41","filename":"tests/unit/performance/PerformanceOptimizerAdvanced.test.js","status":"added","additions":274,"deletions":0,"changes":274,"blob_url":"https://github.com/cowcfj/save-to-notion/blob/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/tests%2Funit%2Fperformance%2FPerformanceOptimizerAdvanced.test.js","raw_url":"https://github.com/cowcfj/save-to-notion/raw/a00f4f4ece242ae05b3e35d5e62db9fb46a69bac/tests%2Funit%2Fperformance%2FPerformanceOptimizerAdvanced.test.js","contents_url":"https://api.github.com/repos/cowcfj/save-to-notion/contents/tests%2Funit%2Fperformance%2FPerformanceOptimizerAdvanced.test.js?ref=a00f4f4ece242ae05b3e35d5e62db9fb46a69bac","patch":"@@ -0,0 +1,274 @@\n+/**\n+ * PerformanceOptimizer 進階功能測試\n+ * 測試新增的緩存預熱、TTL 機制、批處理優化和自適應功能\n+ */\n+\n+// 模擬 DOM 環境\n+const { JSDOM } = require('jsdom');\n+const dom = new JSDOM(`\n+<!DOCTYPE html>\n+<html>\n+<head><title>Test</title></head>\n+<body>\n+    <div class=\"test-container\">\n+        <img src=\"test1.jpg\" alt=\"Test 1\">\n+        <img src=\"test2.jpg\" alt=\"Test 2\">\n+        <article>\n+            <h1>Article Title</h1>\n+            <p>Test paragraph 1</p>\n+            <p>Test paragraph 2</p>\n+            <img class=\"article-img\" src=\"article.jpg\" alt=\"Article image\">\n+        </article>\n+        <main>\n+            <p>Main content paragraph</p>\n+            <img class=\"main-img\" src=\"main.jpg\" alt=\"Main image\">\n+        </main>\n+        <a href=\"#test\">Test link</a>\n+    </div>\n+</body>\n+</html>\n+`);\n+\n+// 設置全局變量\n+global.document = dom.window.document;\n+global.window = dom.window;\n+global.performance = {\n+    now: () => Date.now(),\n+    memory: {\n+        usedJSHeapSize: 1000000,\n+        totalJSHeapSize: 2000000,\n+        jsHeapSizeLimit: 4000000\n+    }\n+};\n+\n+// 確保 DOM 查詢方法可用\n+global.document.querySelector = dom.window.document.querySelector.bind(dom.window.document);\n+global.document.querySelectorAll = dom.window.document.querySelectorAll.bind(dom.window.document);\n+\n+// 引入性能優化器\n+const { PerformanceOptimizer } = require('../../helpers/performance.testable');\n+\n+describe('PerformanceOptimizer 進階功能測試', () => {\n+    let optimizer;\n+\n+    beforeEach(() => {\n+        optimizer = new PerformanceOptimizer({\n+            enableCache: true,\n+            enableBatching: true,\n+            enableMetrics: true,\n+            cacheMaxSize: 100,\n+            cacheTTL: 300000 // 5分鐘 TTL\n+        });\n+    });\n+\n+    describe('TTL 機制和緩存管理', () => {\n+        test('應該支持 TTL 機制', () => {\n+            const selector = 'img';\n+            \n+            // 第一次查詢，結果會被緩存\n+            const result1 = optimizer.cachedQuery(selector, document);\n+            expect(result1).toBeDefined();\n+\n+            // 驗證結果已緩存\n+            const stats = optimizer.getPerformanceStats();\n+            expect(stats.cache.size).toBeGreaterThan(0);\n+\n+            // 檢查緩存對象是否包含 TTL 信息\n+            const cacheKeys = Array.from(optimizer.queryCache.keys());\n+            if (cacheKeys.length > 0) {\n+                const cachedItem = optimizer.queryCache.get(cacheKeys[0]);\n+                expect(cachedItem).toHaveProperty('timestamp');\n+                expect(cachedItem).toHaveProperty('ttl');\n+            }\n+        });\n+\n+        test('應該清理過期緩存', () => {\n+            const selector = 'p';\n+            \n+            // 添加項目到緩存\n+            optimizer.cachedQuery(selector, document);\n+            expect(optimizer.getPerformanceStats().cache.size).toBeGreaterThan(0);\n+\n+            // 手動設置一個過期的緩存項目\n+            const expiredKey = 'expired_test_key';\n+            optimizer.queryCache.set(expiredKey, {\n+                result: 'test_result',\n+                timestamp: Date.now() - 400000, // 5分鐘前，已過期\n+                ttl: 300000\n+            });\n+\n+            // 清理過期緩存\n+            const clearedCount = optimizer.clearExpiredCache();\n+            \n+            // 應該至少清理一個過期項目\n+            expect(clearedCount).toBeGreaterThanOrEqual(1);\n+            \n+            // 如果清理了項目，則當前緩存大小應小於或等於原始大小\n+            const finalStats = optimizer.getPerformanceStats();\n+            expect(finalStats.cache.size).toBeGreaterThanOrEqual(0);\n+        });\n+\n+        test('應該強制刷新特定選擇器緩存', () => {\n+            const selector = 'a';\n+            \n+            // 初始查詢\n+            const result1 = optimizer.cachedQuery(selector, document);\n+            expect(result1).toBeDefined();\n+\n+            // 刷新緩存\n+            optimizer.refreshCache(selector);\n+\n+            // 再次查詢，雖然緩存被刷新，但結果應該相同\n+            const result2 = optimizer.cachedQuery(selector, document);\n+            expect(result2).toBeDefined();\n+        });\n+\n+        test('應該維護緩存大小限制', () => {\n+            // 創建一個小容量的優化器\n+            const smallOptimizer = new PerformanceOptimizer({\n+                cacheMaxSize: 2,\n+                cacheTTL: 300000\n+            });\n+\n+            // 添加超過限制的查詢\n+            smallOptimizer.cachedQuery('img');\n+            smallOptimizer.cachedQuery('p');\n+            smallOptimizer.cachedQuery('a');  // 這應該觸發 LRU 驅逐\n+\n+            const stats = smallOptimizer.getPerformanceStats();\n+            expect(stats.cache.size).toBeLessThanOrEqual(2);\n+        });\n+    });\n+\n+    describe('緩存預熱功能', () => {\n+        test('應該預熱選擇器', async () => {\n+            const selectors = ['img', 'p', 'article'];\n+            \n+            // 預熱選擇器\n+            const results = await optimizer.preloadSelectors(selectors);\n+            \n+            expect(Array.isArray(results)).toBe(true);\n+            expect(results.length).toBe(selectors.length);\n+            \n+            // 驗證預熱計數增加\n+            const stats = optimizer.getPerformanceStats();\n+            expect(stats.cache.prewarms).toBeGreaterThan(0);\n+            expect(stats.cache.hitRate).toBeDefined();\n+        });\n+\n+        test('應該進行智能預熱', async () => {\n+            // 執行智能預熱\n+            const results = await optimizer.smartPrewarm(document);\n+            \n+            expect(Array.isArray(results)).toBe(true);\n+            expect(results.length).toBeGreaterThanOrEqual(0);\n+            \n+            // 確保一些選擇器被預熱\n+            const stats = optimizer.getPerformanceStats();\n+            expect(stats.cache.prewarms).toBeGreaterThanOrEqual(0);\n+            \n+            // 驗證預熱選擇器計數\n+            expect(stats.cache.prewarmCount).toBeGreaterThanOrEqual(0);\n+        });\n+\n+        test('應該避免重複預熱相同選擇器', async () => {\n+            const selector = 'img';\n+            \n+            // 第一次預熱\n+            const result1 = await optimizer.preloadSelectors([selector]);\n+            \n+            // 第二次預熱相同的選擇器\n+            const result2 = await optimizer.preloadSelectors([selector]);\n+            \n+            // 第二次預熱不應產生新的預熱計數\n+            const stats = optimizer.getPerformanceStats();\n+            expect(stats.cache.prewarms).toBeGreaterThanOrEqual(0);\n+        });\n+    });\n+\n+    describe('改進的批處理系統', () => {\n+        test('應該動態計算最佳批處理大小', () => {\n+            // 測試不同的隊列大小\n+            const size0 = optimizer._calculateOptimalBatchSize.call(optimizer);\n+            expect(size0).toBe(100); // 默認大小\n+\n+            // 模擬不同隊列長度\n+            optimizer.batchQueue = new Array(10);\n+            const size1 = optimizer._calculateOptimalBatchSize.call(optimizer);\n+            expect(size1).toBe(50); // 中等大小\n+\n+            optimizer.batchQueue = new Array(300);\n+            const size2 = optimizer._calculateOptimalBatchSize.call(optimizer);\n+            expect(size2).toBe(150); // 較大\n+\n+            optimizer.batchQueue = new Array(600);\n+            const size3 = optimizer._calculateOptimalBatchSize.call(optimizer);\n+            expect(size3).toBe(200); // 最大\n+        });\n+\n+        test('應該支持非阻塞批處理', async () => {\n+            const items = Array.from({ length: 25 }, (_, i) => ({ id: i, value: `item${i}` }));\n+            const processor = (item) => ({ ...item, processed: true });\n+\n+            // 使用批處理處理項目\n+            const results = await optimizer._processInBatches(items, 10, processor);\n+\n+            expect(results).toHaveLength(25);\n+            expect(results.every(r => r.processed)).toBe(true);\n+        });\n+\n+        test('應該根據性能動態調整批處理大小', () => {\n+            const originalSize = 50;\n+\n+            // 模擬低性能場景\n+            optimizer.metrics.averageProcessingTime = 200; // 高處理時間\n+            const adjustedSize1 = optimizer._adjustBatchSizeForPerformance.call(optimizer, originalSize);\n+            expect(adjustedSize1).toBeLessThan(originalSize);\n+\n+            // 模擬高性能場景\n+            optimizer.metrics.averageProcessingTime = 5; // 低處理時間\n+            const adjustedSize2 = optimizer._adjustBatchSizeForPerformance.call(optimizer, originalSize);\n+            expect(adjustedSize2).toBeGreaterThan(originalSize);\n+        });\n+    });\n+\n+    describe('自適應性能功能', () => {\n+        test('應該初始化自適應管理器', () => {\n+            // 創建帶有自適應功能的優化器\n+            const adaptiveOptimizer = new PerformanceOptimizer({\n+                enableCache: true,\n+                enableBatching: true,\n+                enableMetrics: true,\n+                enableAdaptive: true\n+            });\n+\n+            // 檢查是否初始化了自適應管理器\n+            // 由於 AdaptivePerformanceManager 可能不存在於測試環境中，我們測試它的存在性\n+            expect(adaptiveOptimizer).toBeDefined();\n+        });\n+\n+        test('應該分析頁面內容', () => {\n+            const analysis = optimizer._analyzePageForPrewarming(document);\n+            expect(Array.isArray(analysis)).toBe(true);\n+            \n+            // 應該包含一些基於文檔結構的選擇器\n+            expect(analysis.length).toBeGreaterThanOrEqual(0);\n+        });\n+\n+        test('應該讓出控制權給主線程', async () => {\n+            // 測試讓出控制權功能\n+            const result = await optimizer._yieldToMain.call(optimizer);\n+            expect(result).toBeUndefined(); // setTimeout(resolve) 返回 undefined\n+        });\n+    });\n+\n+    describe('系統負載調整', () => {\n+        test('應該根據系統負載調整性能參數', async () => {\n+            // 模擬不同性能場景並測試調整\n+            optimizer.metrics.averageProcessingTime = 100; // 假設處理時間較長\n+            \n+            // 測試調整功能不拋出錯誤\n+            await expect(optimizer.adjustForSystemLoad()).resolves.not.toThrow();\n+        });\n+    });\n+});\n\\ No newline at end of file"}]